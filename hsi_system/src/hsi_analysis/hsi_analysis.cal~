/**
 * Hyperspectral Imaging Algorithms Library
 *
 * @file
 * @brief Library of common functions to implement algorithms for analyzing hyperspectral images
 * 
 * @author Raquel Lazcano
 * @author Daniel MadroÃ±al
 * @version 1.0
 * @date July 2014
 */


package hsi_analysis;


unit hsi_analysis:
	uint(size=32) MAX = 10000;
	uint(size=32) rowsMax = 4096;
	uint(size=32) columnsMax = 4096;
	uint(size=32) bandsMax = 4096;

	/*File reading and writing */
	
	/**
	 * @brief Read a .txt file with configuration parameters. The file should be in the folder where the executable file is generated
	 * @param typeName Number to select the parameter we want to obtain (0...6)
	 * @return the selected parameter
	*/
	@native function source_readConfig(int(size=32) tipo) --> int(size=32)
	end
	
	/**
	 * @brief Generate the Data.cal file. This function is only used to generate the output of algorithms related to endmember estimation
	 * @param rows Number of rows of the original hyperspectral image
	 * @param columns Number of columns of the original hyperspectral image
	 * @param bands Number of bands of the original hyperspectral image
	 * @param nbits Number of bits of each pixel
	 * @param nformat Number to select the format: 0 - BSQ, 1 - BIP, 2 - BIL
	 * @param numPC Number of principal components (PCA algorithm)
	 * @param numEnd Number of endmembers 
	 */
	@native procedure gen_conf_data(int(size=32) rows, int(size=32) columns, int(size=32) bands, int(size=32) nbits, int(size=32) nformat, int(size=32) numPC,int(size=32) numEnd)
	end
	
	/**
	 * @brief Write an image into a binary file, with the BSQ format of an hyperspectral image. This function should be used to write images generated by the Source.cal given. matrixOut must be short int
	 * @param matrixOut Image to save in the binary file
	 * @param rows Number of rows of matrixOut
	 * @param columns Number of columns of matrixOut
	 * @param fileName Name of the generated file
	 */
	@native procedure write_short_BSQ(int(size=16) matrixOut[MAX][MAX], int(size = 32) rc, int(size = 32) bands, String fileName) 
	end
	
	/**
	 * @brief Write an image into a binary file, with the BIP format of an hyperspectral image. This function should be used to write images generated by the Source.cal given. matrixOut must be short int
	 * @param matrixOut Image to save in the binary file
	 * @param rows Number of rows of matrixOut
	 * @param columns Number of columns of matrixOut
	 * @param fileName Name of the generated file
	 */
	@native procedure write_short_BIP(int(size=16) matrixOut[MAX][MAX], int(size = 32) rc, int(size = 32) bands, String fileName) 
	end
	
	/**
	 * @brief Write an image into a binary file, with the BSQ format of an hyperspectral image. This function should be used to write images implemented with double type of data
	 * @param matrixOut Image to save in the binary file
	 * @param rows Number of rows of matrixOut
	 * @param columns Number of columns of matrixOut
	 * @param fileName Name of the generated file
	 */
	@native procedure write_double_BSQ(double matrixOut[MAX][MAX], int(size = 32) rc, int(size = 32) bands, String fileName) 
	end
	
	/**
	 * @brief Generate a complete hyperspectral image, which has two files: a binary file and a .hdr file. The last one is the header of the binary file, and it must have the same name than the binary file, but with the .hdr extension. The file is written in the bin directory of the project
	 * @param matrixOut Image to save in the binary file
	 * @param rows Number of rows of matrixOut
	 * @param columns Number of columns of matrixOut
	 * @param lines Number of lines of the initial image
	 * @param samples Number of samples of the initial image
	 * @param bands Number of bands of the hyperspectral image
	 * @param numEnd Number of endmembers of the hyperspectral image
	 * @param path Path to the hyperspectral image associated with the .hdr generated
	 * @param fileName Name of the binary file 
	 * @param typeFile Number to select the file we want to generate: 1 - Dimensionality reduction, 2 - Endmembers, 3 - Abundances
	 */
	@native procedure gen_hdr(double matrixOut[MAX][MAX], int(size=32) rows, int(size=32) columns, int(size=32) lines, int(size=32) samples, int(size=32) bands, int(size=32) numEnd, String path, String fileName, int(size=32) typeFile)
	end
	
	/**
	 * @brief Read a .txt file and save its contents in a matrix. Hence, the .txt file should contain only a matrix, and it should be in the folder where the executable file is generated
	 * @param matrixIn[MAX][MAX] Matrix where the result is going to be saved
	 * @param rows Number of rows of matrixIn
	 * @param columns Number of columns of matrixIn
	 * @param fileName Name of the required .txt file. The extension must be also written in this parameter 
	 */
	@native procedure read_file(double matrixIn[MAX][MAX], int(size = 32) rows, int(size = 32) columns, String fileName)
	end
	
	/**
	 * @brief Save a matrix into a .txt file. This file is generated in the bin folder of the project
	 * @param matrixOut[MAX][MAX] Matrix to be saved in the .txt file
	 * @param rows Number of rows of matrixOut
	 * @param columns Number of columns of matrixOut
	 * @param fileName Name of the output .txt file. The extension must be also written in this parameter
	 */
	@native procedure write_file(double matrixOut[MAX][MAX], int(size = 32) rows, int(size = 32) columns, String fileName)
	end	
	
	/*PCA */
	
	/**
	 * @brief Get the mean value of a given vector
	 * @param vector[MAX] Vector whose mean value we want to obtain
	 * @param positions Size of vector
	 * @return Mean Value
	 */
	@native function mean_vector(double vector[MAX], int(size = 32) positions) --> double
	end
	
	/**
	 * @brief Subtract the same value from each position of a vector
	 * @param vectorIn[MAX] Each position is the minuend of each subtraction
	 * @param value Common subtrahend of each subtraction
	 * @param vectorMinus[MAX] Vector where the result is saved
	 * @param positions Size of vectorIn
	 */
	@native procedure vector_minus_value(double vectorIn[MAX], double value, double vectorMinus[MAX], int(size=32) positions)
	end
	
	/**
	 * @brief Transpose a matrix
	 * @param matrixIn[MAX][MAX] Matrix whose transpose we want to obtain
	 * @param matrixTraspose[[MAX][MAX] Matrix where the result is saved
	 * @param rows Number of rows of matrixIN
	 * @param columns Number of columns of matrixIN
	 */
	@native procedure transpose(double matrixIn[MAX][MAX], double matrixTranspose[MAX][MAX], double rows, double columns)
	end
	
	/**
	 * @brief Multiply two vectors
	 * @param vector1[columns] First factor
	 * @param vector2[rows] Second factor
	 * @param positions Number of elements of each vector
	 * @return Product
	 */
	@native function vector_mult(double vector1[columnsMax], double vector2[rowsMax], int(size=32) positions) --> double
	end
	
	/**
	 * @brief Multiply two matrices
	 * @param matrix1[MAX][MAX] First factor
	 * @param matrix2[MAX][MAX] Second factor
	 * @param matrixResult[MAX][MAX] Product
	 * @param rows1 Number of rows of first factor
	 * @param columns1 Number of columns of first factor
	 * @param rows2 Number of rows of second factor
	 * @param columns2 Number of columns of second factor
	 */
	@native procedure matrix_mult(double matrix1[MAX][MAX], double matrix2[MAX][MAX], double matrixResult[MAX][MAX], double rows1, double columns1, double rows2, double columns2)
	end
	
	/**
	 * @brief Get the diagonal vector of a matrix
	 * @param matrix[MAX][MAX] Matrix whose diagonal we want to obtain (it has to be a square matrix)
	 * @param vectorDiag[MAX] Diagonal vector (result)
	 * @param positions Number of rows or columns of matrix
	 */
	@native procedure get_diagonal(double matrix[MAX][MAX], double vectorDiag[MAX], int(size=32) positions)
	end
	
	/**
	 * @brief Get the eigenvectors matrix 
	 * @param matrixIn[MAX][MAX] Matrix whose eigenvectors we want to obtain (it has to be a square matrix)
	 * @param matrixEigenvectors[MAX][MAX] Eigenvectors matrix (result)
	 * @param rows Number of rows of matrixIN
	 * @param columns Number of columns of matrixIN
	 */
	@native procedure get_eigenvectMatrix(double matrixIn[MAX][MAX],double matrixEigenvectors[MAX][MAX], int(size=32) rows, int(size=32) columns)
	end
	
	/**
	 * @brief Reduce matrix dimensions
	 * @param matrix1[MAX][MAX] Matrix whose dimensions we want to reduce 
	 * @param matrix2[MAX][MAX] Reduced matrix (result)
	 * @param rows1 Number of rows of matrix1
	 * @param columns1 Number of columns of matrix1
	 * @param rows2 Number of rows of matrix2
	 * @param columns2 Number of columns of matrix2
	 */	
	@native procedure matrix_reduce(double matrix1[MAX][MAX], double matrix2[MAX][MAX], double rows1, double columns1, double rows2, double columns2)
	end
	
	/*VCA */
	
	/**
	 * @brief Get the logarithm of a number (base 10): result = log(value)
	 * @param value Number whose logarithm we want to calculate
	 * @return Result
	 */
	@native function log(double value) --> double
	end
	
	/**
	 * @brief Divide each element of a matrix by the same value
	 * @param matrixIn[MAX][MAX] Each element of this matrix is the dividend of each operation
	 * @param matrixOut[MAX][MAX] Result of the division
	 * @param value Divider of each operation
	 * @param rows Number of rows of matrixIN
	 * @param columns Number of columns of matrixIN
	 */
	@native procedure matrix_scale(double matrixIn[MAX][MAX], double matrixOut[MAX][MAX], double value, int(size = 32) rows, int(size = 32) columns)
	end
	
	/**
	 * @brief Raise a number to a given power
	 * @param base Number we want to raise to a certain power
	 * @param power Power 
	 * @return Result
	 */
	@native function elev(double base, double power) --> double
	end
	
	/**
	 * @brief Square each element of each row and add them, row by row
	 * @param matrix[MAX][MAX] Matrix to use in the operation
	 * @param rows Number of rows of matrix
	 * @param columns Number of columns of matrix
	 * @return The function returns the square root of the largest row sum of squares
	 */
	@native function maxSqrtSum(double matrix[MAX][MAX], double rows, double columns) --> double
	end
	
	/**
	 * @brief Extend a matrix
	 * @param matrixIn[MAX][MAX] Matrix whose dimensions we want to extend 
	 * @param matrixOut[MAX][MAX] Extended matrix (result)
	 * @param rows1 Number of rows of matrixIn
	 * @param columns1 Number of columns of matrixIn
	 * @param rows2 Number of rows of matrixOut
	 * @param columns2 Number of columns of matrixOut
	 */
	@native procedure matrix_extend(double matrixIn[MAX][MAX], double matrixOut[MAX][MAX], double rows1, double columns1, double rows2, double columns2)
	end
	
	/**
	 * @brief Set a column of the matrix to the same value
	 * @param matrixIn[MAX][MAX] Matrix whose column we want to fill
	 * @param rows1 Number of rows of matrixIn
	 * @param columns1 Number of columns of matrixIn
	 * @param column Position of the filled column
	 * @param value Value of each element of the filled column
	 */
	@native procedure matrix_fill_column(double matrixIn[MAX][MAX], double rows1, double columns1, double column, double value)
	end
	
	/**
	 * @brief Cast between int and double types
	 * @param value double value
	 * @return The same value, but as an int
	 */
	@native function double_to_int(double value) --> int(size = 32)
	end
	
	/**
	 * @brief Cast between int and double types
	 * @param value int value
	 * @return The same value, but as a double
	 */
	@native function int_to_double(int(size = 32) value) --> double
	end
	
	/**
	 * @brief Fill a vector with random values between 0 and 1 (of double type)
	 * @param vector[MAX] Vector filled with random values
	 * @param positions Number of elements of vector 
	 */
	@native procedure random_vector(double vector[MAX], double positions)
	end
	
	/**
	 * @brief Get a pseudo - inverse matrix 
	 * @param matrixIn[MAX][MAX] Matrix whose pseudo - inverse we want to obtain (it has to be a square matrix)
	 * @param matrix_p_inverse[MAX][MAX] Pseudo - inverse matrix (result)
	 * @param rows Number of rows of matrixIN
	 * @param columns Number of columns of matrixIN
	 */
	@native procedure get_pinverse(double matrixIn[MAX][MAX],double matrix_p_inverse[MAX][MAX], int(size=32) rows, int(size=32) columns)
	end
	
	/**
	 * @brief Subtract one vector from another
	 * @param vector1[MAX] Minuend vector
	 * @param vector2[MAX] Subtrahend vector
	 * @param vectorResult[MAX] Vector where the result is saved
	 * @param positions Size of vector1 and vector2 (they must have the same number of elements)
	 */
	@native procedure vector_minus_vector(double vector1[MAX], double vector2[MAX], double vectorResult[MAX], int(size=32) positions)
	end
	
	/**
	 * @brief Get the square root of a number
	 * @param value Radicand
	 * @return Result
	 */
	@native function sq_root(double value) --> double
	end
	
	/**
	 * @brief Get the position of the largest element vector (absolute values only)
	 * @param vector[MAX] Vector to use in the operation
	 * @param positions Number of elements of vector
	 * @return Returns the position (index) of the largest element vector
	 */
	@native function getIndexMax(double vector[MAX], int(size = 32) positions) --> int(size=32)
	end
	
	/**
	 * @brief Return the remainder of a division 
	 * @param dividend Dividend of the division
	 * @param divisor Divisor of the division
	 * @return Remainder of the division
	 */
	@native function rem(double dividend, int(size=32) divisor) --> int(size = 32)
	end
	
	/**
	 * @brief Get the inverse matrix 
	 * @param matrixIn[MAX][MAX] Matrix whose inverse we want to obtain (it has to be a square matrix)
	 * @param matrix_inverse[MAX][MAX] Inverse matrix (result)
	 * @param rows Number of rows of matrixIN
	 * @param columns Number of columns of matrixIN
	 */
	@native procedure get_inverse(double matrixIn[MAX][MAX], double matrix_inverse[MAX][MAX], int(size=32) rows, int(size=32) columns)
	end
	
	/**
	 * @brief Multiply a matrix by a vector (the result is a vector)
	 * @param matrix1[MAX][MAX] First factor
	 * @param vector[MAX] Second factor
	 * @param vectorResult[MAX] Product
	 * @param rows1 Number of rows of first factor
	 * @param columns1 Number of columns of first factor
	 * @param positions_vector Number of elements of second factor
	 */
	@native procedure matrix_mult_vector(double matrix1[MAX][MAX], double vector[MAX], double vectorResult[MAX], double rows1, double columns1, double positions_vector)
	end
	
	/**
	 * @brief Divide each element of a vector by the same value
	 * @param vectorIn[MAX] Each element of this vector is the dividend of each operation
	 * @param vectorOut[MAX] Result of the division
	 * @param value Divider of each operation
	 * @param positions Number of elements of vectorIN
	 */
	@native procedure vector_scale(double vectorIn[MAX], double vectorOut[MAX], double value, int(size = 32) positions)
	end
	
	/**
	 * @brief Cast between float and double types
	 * @param value double value
	 * @return The same value, but as a float
	 */	
	@native function double_to_float(double value) --> float
	end
	
	/**
	 * @brief Cast between float and double types
	 * @param value float value
	 * @return The same value, but as a double
	 */
	@native function float_to_double(float value) --> double
	end
	
	/**
	 * @brief Get a certain column from a matrix
	 * @param matrix1[MAX][MAX] Matrix whose column we want to obtain
	 * @param vector[MAX] Vector where the required column is saved
	 * @param rows1 Number of rows of matrix1
	 * @param columns1 Number of columns of matrix1
	 * @param column Pointer to the required column
	 */
	@native procedure matrix_get_column(double matrix1[MAX][MAX], double vector[MAX], double rows1, double columns1, double column)
	end
	
	/**
	 * @brief Set a certain column of a matrix
	 * @param matrix1[MAX][MAX] Matrix whose column we want to modify
	 * @param vector[MAX] Contains the new values of the column we want to edit
	 * @param rows1 Number of rows of matrix1
	 * @param columns1 Number of columns of matrix1
	 * @param column Pointer to the column we want to edit
	 */
	@native procedure matrix_set_column(double matrix1[MAX][MAX], double vector[MAX], double rows1, double columns1, double column)
	end
	
	/**
	 * @brief Get a certain row from a matrix
	 * @param matrix1[MAX][MAX] Matrix whose row we want to obtain
	 * @param vector[MAX] Vector where the required row is saved
	 * @param rows1 Number of rows of matrix1
	 * @param columns1 Number of columns of matrix1
	 * @param column Pointer to the required row
	 */ 
	@native procedure matrix_get_row(double matrix1[MAX][MAX], double vector[MAX], int rows1, int columns1, int row)
	end
	
	/**
	 * @brief Set a certain row of a matrix
	 * @param matrix1[MAX][MAX] Matrix whose row we want to modify
	 * @param vector[MAX] Contains the new values of the row we want to edit
	 * @param rows1 Number of rows of matrix1
	 * @param columns1 Number of columns of matrix1
	 * @param column Pointer to the row we want to edit
	 */
	@native procedure matrix_set_row(double matrix1[MAX][MAX], double vector[MAX], double rows1, double columns1, double row)
	end
	
	/**
	 * @brief Add the same value to all the elements of a matrix
	 * @param matrixIN[MAX][MAX] Matrix whose elements we want to edit
	 * @param matrixOut[MAX][MAX] Matrix where the result is saved
	 * @param value Value to add
	 * @param rows Number of rows of matrixIN
	 * @param columns Number of columns of matrixIN
	 */
	@native procedure matrix_plus_value(double matrixIN[MAX][MAX], double matrixOut[MAX][MAX], double value, int rows, int columns)
	end
	
	/**
	 * @brief Deduct two matrices
	 * @param matrix1[MAX][MAX] Minuend
	 * @param matrix2[MAX][MAX] Subtrahend
	 * @param matrixOut[MAX][MAX] Matrix where the result is saved
	 * @param rows Number of rows of matrix1 and matrix2
	 * @param columns Number of columns of matrix1 and matrix2
	 */
	@native procedure matrix_minus_matrix(double matrix1[MAX][MAX], double matrix2[MAX][MAX], double matrixOut[MAX][MAX], int rows, int columns)
	end
	
	/**
	 * @brief Multiply a matrix by a vector
	 * @param vector[MAX] First factor
	 * @param matrix1[MAX][MAX] Second factor
	 * @param vectorResult[MAX] Vector where the result is saved
	 * @param positions_vector Number of elements of vector
	 * @param rows1 Number of rows of matrix1
	 * @param columns1 Number of columns of matrix1
	 */
	@native procedure vector_mult_matrix(double vector[MAX], double matrix1[MAX][MAX], double vectorResult[MAX], double positions_vector, double rows1, double columns1)
	end
	
	/**
	 * @brief Deduct the same value to all the elements of a matrix
	 * @param matrixIN[MAX][MAX] Matrix whose elements we want to edit
	 * @param matrixOut[MAX][MAX] Matrix where the result is saved
	 * @param value Value to deduct
	 * @param rows Number of rows of matrixIN
	 * @param columns Number of columns of matrixIN
	 */
	@native procedure matrix_minus_value(double matrixIN[MAX][MAX], double matrixOut[MAX][MAX], double value, int rows, int columns)
	end
	
	/**
	 * @brief Add two matrices
	 * @param matrix1[MAX][MAX] First operand
	 * @param matrix2[MAX][MAX] Second operand
	 * @param matrixOut[MAX][MAX] Matrix where the result is saved
	 * @param rows Number of rows of matrix1 and matrix2
	 * @param columns Number of columns of matrix1 and matrix2
	 */
	@native procedure matrix_plus_matrix(double matrix1[MAX][MAX], double matrix2[MAX][MAX], double matrixOut[MAX][MAX], int rows, int columns)
	end
	
	/**
	 * @brief Get the real time of the system (in seconds, with a resolution of nanoseconds)
	 * @return System time
	 */
	@native function get_time() --> double
	end
	
	@native procedure end_program()
	end
	
end



